---
title: Java - Collection Basic & Hash Basic
author: Daehong
date: 2023-11-29
category: Jekyll
layout: post
mermaid: true
---

* Deep 한 내용이 아닌, 가벼운 Basic 한 내용만 담았다.

<hr>

### 1. List
* 동일한 객체 타입에 대하여 중복을 허용하며, 입력한 순서를 유지하고, 빈틈 없이 데이터를 적재하는 자료구조이다.
* 기본 크기는 10이며, 부하율이 0.75가 넘어가면 크기를 확장한다.
	* 확장은 내부적으로 알아서 이루어지며 크기를 추가로 늘린 새로운 리스트를 생성하고 거기에 옮겨 담는다.
	* 초기 크기를 직접 지정할 수 있기 때문에 리스트의 크기가 확정적으로 클 것이라면, 초기 크기를 크게 잡아두는 것도 좋다.
		```java
		List<String> testList = new ArrayList<>(100); // 초기 크기 100
		```
* ArrayList, LinkedList 등이 있다.

<br>
<br>

### 2. Set
* 중복을 허용하지 않는 특징이 있다.
* HashSet
	* 가장 일반적임
* TreeSet
	* 정렬된 순서를 보장한다. 그러나 입력한 순서를 보장하지는 않는다.
* LinkedHashSet
	* 입력한 순서를 보장한다.
	
<br>
<br>

### 3. Queue
* 선입선출(FIFO) 방식을 사용하며 선언 시에 LinkedList<>로 구현체를 만드는 것이 일반적이다.
* 그러나 우선순위에 따라 요소를 관리하는 PriorityQueue<>나, 큐의 두 끝에서 요소를 추가하거나 제거할 수 있는 ArrayDeque<>로 상황따라 선언하기도 한다.
* offer() 와 poll() 그리고 peak() 등의 메서드가 있다.

<br>
<br>

### 4. Stack
* 후입선출(LIFO) 방식을 사용한다.
* JVM 메모리 스택 영역과 동일한 방식의 자료구조이다.
* push(), pop(), peak() 등의 메서드를 사용한다.

<br>
<br>

### 5. Hash
#### 5.1. Hash Basic
* 일반적으로 데이터를 고정된 크기의 값으로 변환하는 알고리즘 또는 함수를 의미한다.
* key와 Value로 나뉘어져 있으며, Key를 가지고 Value를 찾는 방식이다.
* Map에서 하나의 Key, Value가 저장되어있는 공간을 버킷이라고 한다.
* HashTable, HashMap, ConcurrentHashMap 등이 있다.
	* HashTable은 Null을 허용하지 않고, 현재는 별로 사용하지 않는다. 동기화는 지원하지만 성능이 좋지 않다.
	* HashMap은 Null을 허용하고, 일반적으로 많이 쓰인다. 그러나 동기화를 지원하지 않아 멀티 스레드 환경에서는 적합하지 않다.
	* ConcurrentHashMap은 Null도 지원하고 동기화도 지원한다. 내부에서 데이터를 관리하는데 해시 버킷을 분할하여 여러 섹션으로 나누어 동시성을 향상시킨다.


<br>

#### 5.2. Hash Collision ( 해시 충돌 )
* Hash는 Key값을 hashcode로 먼저 비교를 한 후 equals로 비교를 한다.
* 이 때 둘 다 같으면, 아예 동일한 Key로 간주하고 값을 덮어씌운다거나 한다.
* 그러나 hashcode는 같고, equals 만 다른 경우가 있다.
* 이럴경우 일어나는게 해시충돌이다.
* hashcode는 고유하지 않기 때문에, 어쩌다보니 같은 hashcode가 들어갈 수도 있고, hashcode가 재정의 되어있지 않은 경우에 문제가 생길 수도 있다.
* 이럴경우 Hash는 내부적으로 Spearate Chaning 방식을 사용하여 추가적인 공간을 활용하여 해결한다.
	* 충돌한 Key-Value 쌍이 적으면 Linked List로 작동하고
	* 충돌한 Key-Value 쌍이 많으면 Red Black Tree 알고리즘 방식으로 작동하여 연결한다.

<br>

* 이걸 실험하기 위해 Integer a = new Integer(7); Integer b = new Integer(7); 을 Hash에 넣어 실험하려 하였으나 실패하였다.
	* Integer는 hashcode가 곧 value 값이 되게끔 재정의 되어있기 때문이다.
	* 그리고 신기한 점을 발견하였는데, Integer는 -128 ~ 127까지는 같은 객체 주소를 공유한다.
	* 즉, Integer a = new Integer(1); 과 Integer b = new Integer(1); 을 하면
	* a == b가 true가 나온다.
	* 근데 Integer a = new Integer(130);Integer b = new Integer(130); 일 때
	* a == b를 하면 false가 나온다.

<br>

#### 5.3. Load Factor
* Set과 Map 에서는 로드 팩터를 기반으로 해당 객체의 저장 공간을 조절한다.
* Set과 Map 에서는 로드 팩터를 기반으로 해당 객체의 저장 공간을 조절한다. 로드 팩터는 기본적으로 (데이터의 개수)/ (저장 공간) 을 의미하며, 이를 기반으로 Map과 Set의 크기를 리사이즈 한다.
* 기본적으로 부여되는 Map 공간 크기는 16이다.
* 초기에 생성자를 통해 초기 공간 크기와 로드 팩터를 정해줄 수 있다. 
* 들어오는 데이터에 비해 로드 팩터가 작을 경우 해시 충돌 및 링크드 리스트를 통한 Separate Chaining이 많이 발생한다. 반대로, 들어오는 데이터에 비해 로드 팩터가 클 경우 메모리 낭비가 발생한다. 따라서 이를 고려하여 설정해야 한다. 일반적으로 0.75의 로드 팩터를 설정하는 것을 이상적으로 생각한다.

<br>
<br>
<br>
<br>
<br>