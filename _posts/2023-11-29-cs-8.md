---
title: CS - Process vs Thread
author: Daehong
date: 2023-11-29
category: Jekyll
layout: post
mermaid: true
---

<hr>

### 1. 프로세스
* 프로세스는 CPU나 메모리등으로부터 독립된 자원을 할딩받아 실행중이고, 동작중인 프로그램을 말한다.
* 프로그램을 그냥 정적인 코드 덩어리라고 한다면, 프로세스는 그러한 프로그램이 동적으로 변하여 돌아가고 있는 상태를 말한다.
* 프로세스 생성에는 큰 오버헤드가 있고, 많은 시간이 소요된다.
	* 오버헤드란?? 어떤 작업을 수행하기 위해 사용되는 자원이나 시간 등의 비용을 의미한다.
* 프로세스와 프로세스 사이의 통신이 어렵다는 특징이 있다.

<br>

### 2. 스레드
* 프로세스 안에서 실행되는 흐름의 단위이며, 프로세스가 할당받은 자원을 스레드끼리 공유하며 사용한다.
* 프로세스는 최소 하나 이상의 스레드를 보유하고 있으며, 스레드는 각각 별도의 주소 공간을 독립적으로 할당 받는다.
* 스레드는 stack만 따로 할당 받고, 나머지 영역은 스레드끼리 공유한다.
* 스레드는 프로세스보다 작은 크기의 실행 단위가 필요해서 만들어졌으며,
* 프로세스를 교체하는 컨텍스트 스위칭보다, 효율이 좋고 빠른 스레드 스위칭을 사용한다.

<br>

### 3. 스레드를 사용하는 이유
* 병렬성 때문에 사용한다.
	* 멀티스레드 형식의 병렬 구조를 활용하여 프로그램 실행 속도를 향상시킬 수 있다.
* 느린 I/O 때문에 프로그램 진행이 Block 되는것을 피할 수 있다.
* 스레드간의 데이터를 공유하기 슆다.

<br>

### 4. 스레드의 공간
* 스레드는 동작하기 위해 총 6가지 공간을 활용한다.
	* 사적 공간
		* 스레드 코드 공간
		* 스레드 전용 전역변수 공간
		* Stack 공간
	* 공유 공간
		* 데이터 공간
		* Heap 공간
	* 커널 스택
	
<br>

### 5. 컨텍스트 스위칭과 스레드 스위칭
* Process 의 경우 현재 프로세스가 중단 되었을 때, 중단된 시점부터 다시 프로세스를 실행하기 위한 정보를 Context 라고 부른다.
* CPU의 Core가 1개라면, 즉 자원이 1개라면, 동시에 하나의 프로세스만 실행이 가능하다.
	* 그래서 CPU 스케쥴링을 통해 작업을 나누어 수행한다.
* 이 때 프로세서가 지금까지 실행되던 프로세스A를 중지하고, 프로세스B의 PCB 정보를 받아, 프로세스B를 실행시키는 것을 Process Context Switching 이라고 한다.
* 스레드도 마찬가지로 동일한 프로세스 속에서 하나의 쓰레드(a)를 중지하고 다른 쓰레드(b)의 TCB정보를 바탕으로 쓰레드 (b)를 실행하는 것을 Thread Context Switching이라고 한다.

<br>

### 6. 멀티 스레드의 장,단점
* 뛰어난 반응성/응답성
	* 프로세스의 일부가 blocked상태여도 실행을 계속하는 것이 가능하다. 이는 특히 유저 인터페이스에 있어 중요하다.
* 자원 공유
	* 스레드끼리는 서로 프로세스의 리소스를 공유하므로, 쉽고 효율적이다.
* 경제성
	* 스레드를 생성하는 것이 프로세스를 생성하는 것보다 비용이 적게 들며,
	* thread switching(스레드 전환)이 context switching(컨텍스트 전환, 즉 프로세스 전환)보다 오버헤드가 적다.
* 확장성
	* 프로세스가 멀티 프로세서 구조의 이점을 적극적으로 활용할 수 있다.
	* 즉, 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가한다.
	
<br>

### 7. 스레드는 어떤 물리적인 자원을 할당 받아서 실행 되는가?
* 스레드는 프로세스 내에서 실행되는 작은 실행 단위로, 기본적으로 프로세스가 할당 받은 물리적인 자원을 공유한다.
	* 프로세스는 운영 체제로부터 메모리 공간, 파일 디스크립터, CPU 시간 등의 자원을 할당받는다.
	
<br>

### 8. 스레드가 CPU보다 많으면?
* 100개, 1,000개, 10,000 개의 스레드를 보내보았지만 잠깐 서버가 중단되는 문제 말고는 오류가 생기지 않았다.
* CPU는 계산을 하는 역할을 하며, I/O에 명령은 내리지만 직접 I/O와는 관계가 없다.
* 그래서 스레드를 네트워크로 보내는 순간부터는 CPU와 연관이 없다.
* 단, 단순히 스레드가 너무 많아서 생기는 문제들은 있을 수 있다.
	* 스레드 스위칭이 너무 많이 일어나면, 그만큼 부하가 생길 수 있다.
	* 스레드를 늘리면 그만큼 Stack이 늘어나므로 자원 소모의 이유가 되기도 한다.
	* 멀티 스레드 구조는 동시성을 일으키는데, 말이 동시성이지 사실은 우리가 느끼지 못할만큼 번갈아가며 스레드들이 실행되기도 한다.
		* 스레드가 너무 많으면, 이런 부분에서 병목현상이나 효과적인 병렬처리가 부족해지는 현상이 일어날 수 있다.

<br>

### 9. 톰캣은 왜 기본 스레드가 200개일까?
* 대부분의 서버 환경에서 웹 애플리케이션이 적당한 성능을 내기 좋은 평균 값이 200개이기 때문이다.

<br>

### 10. CPU 코어에도 캐싱 공간이 있다?
* CPU 에도 캐싱 공간이 있다. 여기에 값이 저장됐다가, 메인 메모리에 올라가고 내리고를 반복한다.
	* 쉽게 말해 쓰레드1을 실행할 CPU 는 쓰레드를 실행할때 필요한 값을 메인메모리에서 카피해와서 CPU 캐시에 담아두고,
	* 쓰레드 1에게 CPU 캐시에 카피해둔 자원에 대한 연산을 진행하도록 지시한다.
	* 그러고 CPU1 의 Cache에 카피해둔 자원에 대해 모든 연산을 반영한 다음,
	* 캐시에 최신화된 값을 메인 메모리에도 반영시켜준다.
* 이러한 경우 생길 수 있는 문제를 "가시성" 이라고 한다.
	```java
	public class VolatileExample {
		private static boolean flag = false;

		public static main(String[] args) {
			// 첫 번째 스레드: flag를 true로 변경
			new Thread(() -> {
				try {
					Thread.sleep(1000); // 다른 스레드에게 시간을 주기 위해 sleep
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				flag = true;
				System.out.println("Flag has been set to true.");
			}).start();

			// 두 번째 스레드: flag가 true가 될 때까지 대기
			new Thread(() -> {
				while (!flag) {
					// flag가 true가 될 때까지 대기
				}
				System.out.println("Flag is now true. Exiting the loop.");
			}).start();
		}
	}
	```
	* 해당 코드처럼 멀티스레드 환경에서 flag가 바뀐다면 그것이 메인메모리에 올라가서, 다른 코어의 캐시들이 받아오기 전까지는 동작이 멈추지 않는다.
	* 이럴경우를 해결하는게 변수에 volatile 이라는 예약어를 입력해주는 것이다. ( private static volatile boolean flag = false; )
	* volatile 에 대해서는 추후 제대로 공부하여 포스팅 할 예정이다, 우선 지금은 이런 가시성을 해결해 줄 수 있다는 것만 알면 된다.
		* syncronized를 사용해도되지만, 이건 하나의 스레드만 접근할 수 있게 잠그는 방법이므로 성능을 저하시킬 수 있다.
		* syncronized를 사용하면 volatile을 쓰지 않아도된다. 하지만 상황에 따라 volatile을 쓰는게 나을 수 있다는 이야기이다.
	
<br>
<br>
<br>
<br>
<br>