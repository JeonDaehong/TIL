---
title: Important Study - Very Important Transaction
author: Daehong
date: 2023-11-29
category: Jekyll
layout: post
mermaid: true
---

<hr>

### Transaction 이란?
 - 데이터베이스에서 수행되는 하나의 논리적인 작업 단위를 의미한다.


<br>
<br>

### ACID
 - 원자성 ( Atomicity )
 
	- 트랜잭션이 속한 하나의 메서드를 하나의 단위로 취급하여, 완전히 Commit 되거나, 완전히 RollBack 되거나 둘 중 하나를 일으킨다.
 
 - 일관성 ( Consistency )

	- 모든 트랜잭션은 일관성 있는 DB 상태를 유지한다. (ex: DB의 무결성 제약 조건 항상 만족)
	
	- 트랜잭션이 시작되기 전과 완료된 후의 데이터베이스 상태는 일관성을 유지해야 한다.
 
 - 고립성 ( Isolation )
 
	- 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션에게 영향을 미치지 않도록 격리되어야 한다.
	
	- 한 트랜잭션이 수행 중인 데이터에 대한 변경 사항은 다른 트랜잭션이 완료되기 전까지는 다른 트랜잭션에게 보이지 않아야 한다.
 
 - 영속성/지속성 ( Durability )
 
	- 트랜잭션이 성공적으로 끝나면 그 결과는 항상 기록되어야 한다.
	
	- 시스템의 장애 또는 기타 문제가 발생하더라도 트랜잭션이 성공적으로 커밋되었으면 그 결과는 지속되어야 한다.
	
<br>
<br>

### 논리적 트랜잭션 & 물리적 트랜잭션
 - 물리적 트랜잭션은 실제로 DB에서 Commit 되거나 RollBack 되는 트랜잭션이다.
 
 - 논리적 트랜잭션은 @Transactional 단위 하나로 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하는 단위이다.
 
 - 논리적 트랜잭션 중 하나라도 문제가 생긴다면, 물리적 트랜잭션은 RollBack 이 일어나고, 논리적 트랜잭션이 전부 정상 작동 되어야지만 물리적 트랜잭션의 Commit 이 일어난다.
 
 - 예시로는 A메서드에 @Transactional 이 걸려있고, 그 안에서 B C 메서드를 호출하고, 이후 B C에서 얻은 결과로 추가 로직을 수행하는 코드가 있는데, B C 메서드에도 @Transactional 이 걸려있다면, A B C 모두 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하지만, A B C 총 3개의 논리적 트랜잭션이 동작하는 것이고, 물리적 트랜잭션은 A 하나만 존재한다. 그래서 B 나 C 혹은 B C 이후 로직 중 하나라도 문제가 생긴다면 RollBack 이 일어나고, 전부 문제 없이 동작해야 Commit 이 된다. 그리고 A 없이 단순이 B만 동작한다면, B는 하나의 물리적트랜잭션이자 동시에 논리적트랜잭션이 된다.
 
 - 그걸 조작하기 위해 @Transactional 에는 propagation 옵션이 존재한다.
 
	- propagation = Propagation.REQUIRED
	
		- 가장 기본이다. propagation = Propagation.REQUIRED 을 굳이 적지 않아도 되며, 안적으면 이 코드로 Default 동작을 한다.
		
		- 기존 트랜잭션이 없으면 생성하고, 기존 트랜잭션이 있으면 기존 트랜잭션에 참여한다.
 
	- propagation = Propagation.SUPPORTS
	
		- 기존 트랜잭션이 있으면 지원하고, 없으면 트랜잭션 없이 진행된다.
		
	- propagation = Propagation.MANDATORY
	
		- 기존 트랜잭션이 반드시 있어야 한다.
		
		- 기존 트랜잭션이 없으면 예외가 발생하고, 있으면 기존 트랜잭션에 참여한다.
		
	- propagation = Propagation.REQUITES_NEW
	
		- 기존 트랜잭션이 없으면 신규 트랜잭션을 생성한다.
		
		- 기존 트랜잭션이 있으면 그 트랜잭션을 잠시 보류하고, 신규 트랜잭션을 생성한다. ( 하나의 물리적 트랜잭션 안에서 새로운 물리적 트랜잭션을 만드는 것이다. )
		
		- 근데 여기서 중요한건, 자식 트랜잭션에서 문제(예외)가 생기면, 부모 트랜잭션은 롤백을 한다.
		
		- 그러나 부모 트랜잭션이 자식 트랜잭션을 성공시키고, 이후 로직에서 문제가 생긴다면, 그 자식 트랜잭션은 commit 되고, 부모 트랜잭션만 롤백된다. 그 개념을 잘 알아야 한다.
			
		- 그 이유는 예외가 발생하였을 때 catch 등으로 처리해주지 않으면 콜 스택을 하나씩 제거하면서 최초 호출한 곳까지 예외가 전파되기 때문이다.
		
		- 고로 독립적인 물리적 트랜잭션을 새로 생성한다는 의미보다는, 별도의 트랜잭션을 생성한다고 보는게 좋다.
		
		- 대신 try catch 로 예외처리를 해준다면, 자식 트랜잭션만 롤백시키고, 부모 트랜잭션은 정상 작동을 시킬 수 있다.
		
		- Propagation.REQUIRED 랑 다를게 뭐냐? 이 경우 Propagation.REQUIRED 를 썼다면, catch 로 예외설정을 잘 해주어도 부모트랜잭션이 롤백을 해버린다.
	
	- propagation = Propagation.NOT_SUPPORTS

		- 트랜잭션을 지원하지 않음.
		
		- 기존 트랜잭션이 없으면 그냥 트랜잭션 없이 진행하고,
		
		- 기존 트랜잭션이 있으면 그 트랜잭션을 보류하고 트랜잭션 없이 진행함.
		
	- propagation = Propagation.NEVER
	
		- 트랜잭션을 사용하지 않음
		
		- 기존 트랜잭션이 없으면 트랜잭션 없이 진행하고
		
		- 기존 트랜잭션이 있으면 예외를 발생시킴
		
	- propagation = Propagation.NESTED
	
		- 자식 트랜잭션을 만듬
		
		- 기존 트랜잭션이 없으면 새 트랜잭션을 생성함
		
		- 기존 트랜잭션이 있으면 자식 트랜잭션을 만듦.
	
<br>
<br>
<br>
<br>
<br>